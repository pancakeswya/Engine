#include "backend/vk/renderer/shader.h"

#include <cstring>
#include <utility>

#include <shaderc/shaderc.hpp>

#include "backend/vk/renderer/error.h"

namespace vk {

namespace {

std::vector<uint32_t> CompileToSpv(const shaderc::Compiler& compiler, shaderc_shader_kind kind, const char* shader_code) {
  const shaderc::SpvCompilationResult module = compiler.CompileGlslToSpv(shader_code, strlen(shader_code), kind, "source");
  if (module.GetCompilationStatus() != shaderc_compilation_status_success) {
    throw Error("failed to compile shaders: " + module.GetErrorMessage());
  }
  return {module.cbegin(), module.cend()};
}

} // namespace

std::vector<ShaderInfo> GetShaders() {
  shaderc::Compiler compiler;
  return {
    {
      VK_SHADER_STAGE_VERTEX_BIT,
      "main",
       CompileToSpv(
         compiler,
         shaderc_vertex_shader,
         R"(@simple.vert@)")
    },
    {
      VK_SHADER_STAGE_FRAGMENT_BIT,
      "main",
      CompileToSpv(
        compiler,
        shaderc_fragment_shader,
        R"(@simple.frag@)")
    }
  };
}

ShaderModule::ShaderModule() noexcept : info_() {
    info_.stage = VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
}

ShaderModule::ShaderModule(ShaderModule&& other) noexcept
  : Dispatchable(std::move(other)), info_(other.info_) {
  other.info_ = {};
  other.info_.stage = VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
}

ShaderModule::ShaderModule(VkShaderModule module,
                           VkDevice logical_device,
                           const VkAllocationCallbacks* allocator,
                           const ShaderInfoBase& info) noexcept
  : Dispatchable(module, logical_device, vkDestroyShaderModule, allocator), info_(info) {}


ShaderModule& ShaderModule::operator=(ShaderModule&& other) noexcept {
  if (this != &other) {
    static_cast<Dispatchable&>(*this) = static_cast<Dispatchable>(std::move(other));
    info_ = std::exchange(other.info_, {});
    info_.stage = VK_SHADER_STAGE_FLAG_BITS_MAX_ENUM;
  }
  return *this;
}

} // namespace vk